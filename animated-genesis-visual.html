<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Upside Attribution Graph</title>
  <!-- Load anime.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: transparent;
      font-family: 'Inter', sans-serif;
    }

    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background-color: transparent;
    }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <div class="container" id="container">
    <svg id="svg"></svg>
  </div>

  <script>
    // Color constants for Upside attribution data
    const COLORS = {
      PEOPLE: "#D94B50",
      PEOPLE_DARK: "#B73E42",
      SIGNALS: "#E6774A",
      SIGNALS_DARK: "#D4653F",
      EVENTS: "#835CE0",
      EVENTS_DARK: "#7049C7",
      ENGAGEMENT: "#347BD1",
      ENGAGEMENT_DARK: "#2D6BB8",
      ROLES: "#66AF48",
      ROLES_DARK: "#5A9B3F",
      FALLBACK: "#F1CA66",
      FALLBACK_DARK: "#E8B955",
      CONNECTION: "#c7cacd",
      WHITE: "white",
      BLACK: "black",
    };

    // Upside attribution data
    const codes = {
      people: [
        { code: "Edith Harris (CEO)", description: "Chief Executive Officer" },
        { code: "VP Legal, Vonda H.", description: "Vice President of Legal" },
        { code: "Marcus Chen (CTO)", description: "Chief Technology Officer" },
        { code: "Sarah Kim (CFO)", description: "Chief Financial Officer" },
        { code: "Director IT, James R.", description: "IT Director" },
        { code: "Lisa Wong (CPO)", description: "Chief Product Officer" },
        { code: "David Miller (VP Sales)", description: "Vice President of Sales" },
        { code: "Head of Security, Alex T.", description: "Security Lead" },
        { code: "Michael Johnson (COO)", description: "Chief Operating Officer" },
        { code: "Emma Rodriguez (CMO)", description: "Chief Marketing Officer" },
      ],
      signals: [
        { code: "Opened Sales Deck", description: "Viewed presentation materials" },
        { code: "Clicked Ad", description: "Engaged with advertising content" },
        { code: "Shared Org Chart", description: "Distributed organizational information" },
        { code: "Downloaded Whitepaper", description: "Accessed thought leadership content" },
        { code: "Visited Pricing Page", description: "Reviewed pricing information" },
        { code: "Watched Demo Video", description: "Consumed product demonstration" },
        { code: "Joined Webinar", description: "Attended online presentation" },
        { code: "Requested Trial", description: "Initiated product evaluation" },
        { code: "Viewed Case Study", description: "Examined success stories" },
        { code: "Subscribed to Newsletter", description: "Opted in for regular updates" },
      ],
      events: [
        { code: "Warriors Game", description: "Corporate entertainment event" },
        { code: "Internal Demo Review", description: "Product demonstration session" },
        { code: "Executive Offsite", description: "Leadership retreat meeting" },
        { code: "Industry Conference", description: "Professional networking event" },
        { code: "Board Meeting", description: "Executive governance session" },
        { code: "Customer Advisory", description: "Strategic feedback session" },
        { code: "Partner Summit", description: "Ecosystem collaboration event" },
        { code: "Product Launch", description: "New feature announcement" },
        { code: "Annual Sales Kickoff", description: "Yearly sales strategy meeting" },
        { code: "Quarterly Business Review", description: "Performance assessment meeting" },
      ],
      engagement_types: [
        { code: "AE Email Intro", description: "Account Executive introduction" },
        { code: "Legal Redlines Sent", description: "Contract markup delivered" },
        { code: "Technical Deep Dive", description: "Product architecture review" },
        { code: "Security Review", description: "Compliance assessment meeting" },
        { code: "Pricing Discussion", description: "Commercial terms negotiation" },
        { code: "Reference Call", description: "Customer testimonial session" },
        { code: "POC Kickoff", description: "Proof of concept initiation" },
        { code: "Executive Briefing", description: "C-level strategic discussion" },
        { code: "Product Roadmap Review", description: "Future development planning" },
        { code: "Implementation Planning", description: "Deployment strategy session" },
      ],
      roles_tags: [
        { code: "Champion Identified", description: "Internal advocate confirmed" },
        { code: "Former Customer", description: "Previous client relationship" },
        { code: "Decision Maker", description: "Final approval authority" },
        { code: "Technical Evaluator", description: "Product assessment lead" },
        { code: "Budget Holder", description: "Financial approval authority" },
        { code: "Influencer", description: "Opinion leader in organization" },
        { code: "End User", description: "Product usage stakeholder" },
        { code: "Procurement Lead", description: "Vendor management contact" },
        { code: "Executive Sponsor", description: "Senior leadership support" },
        { code: "Project Manager", description: "Implementation coordinator" },
      ],
    };

    class KnowledgeGraphAnimation {
      constructor(container) {
        this.container = container;
        this.svg = document.getElementById("svg");
        this.points = [];
        this.connections = [];
        this.showConnections = false;
        this.animationReady = false;
        this.combinationDistance = 25;
        this.startTime = Date.now();
        this.width = 0;
        this.height = 0;
        this.usedCodes = new Set();
        this.connectionRewireInterval = null;

        // Constants
        this.numPoints = 48;
        this.maxSpeed = 0.7;
        this.minSpeed = 0.2;
        this.pointRadius = 4;
        this.pointRadiusVariation = 0.3;
        this.maxConnectionCreateDistance = 180;
        this.maxConnectionBreakDistance = 210;
        this.initialCombinationDistance = 25;
        this.maxCombinationDistance = 80;
        this.combinationDistanceIncreaseRate = 0.01;
        this.connectionLifespan = 30000;
        this.connectionRewireRate = 1500;
        this.connectionRewirePercentage = 0.15;

        this.init();
      }

      init() {
        // Set initial size
        this.updateSize();

        // Initialize points
        this.initializePoints();

        // Create SVG elements
        this.setupSVG();

        // Start animation
        this.animationReady = true;
        this.animate();

        // Always show connections immediately
        this.showConnections = true;
        this.connections = this.calculateConnections();
        this.createConnectionLines();
        this.transformConnectedPoints();

        // Handle window resize
        window.addEventListener("resize", () => this.handleResize());
      }

      updateSize() {
        this.width = this.container.clientWidth;
        this.height = this.container.clientHeight;
        this.svg.setAttribute("width", this.width.toString());
        this.svg.setAttribute("height", this.height.toString());
      }

      getRandomPointValue() {
        try {
          const typeRoll = Math.random();
          let selectedType;
          if (typeRoll < 0.2) selectedType = "people";
          else if (typeRoll < 0.4) selectedType = "signals";
          else if (typeRoll < 0.6) selectedType = "events";
          else if (typeRoll < 0.8) selectedType = "engagement_types";
          else selectedType = "roles_tags";

          const list = codes[selectedType];
          if (!list || list.length === 0) {
            return { code: "Unknown", codeType: selectedType, isCode: false };
          }

          let attempts = 0, item;
          while (attempts < 20) {
            item = list[Math.floor(Math.random() * list.length)];
            if (!this.usedCodes.has(item.code)) {
              this.usedCodes.add(item.code);
              return { code: item.code, description: item.description, codeType: selectedType, isCode: false };
            }
            attempts++;
          }

          // fallback
          return { code: this.generateUniqueCode(selectedType), description: "", codeType: selectedType, isCode: false };
        } catch (e) {
          console.error(e);
          return { code: "ERROR", codeType: "people", isCode: false };
        }
      }

      generateUniqueCode(type) {
        const id = Math.floor(Math.random() * 10000);
        switch (type) {
          case "people": return `Director ${id}`;
          case "signals": return `Viewed Resource ${id}`;
          case "events": return `Session ${id}`;
          case "engagement_types": return `Call ${id}`;
          case "roles_tags": return `Stakeholder ${id}`;
          default: return `Unknown ${id}`;
        }
      }

      initializePoints() {
        this.points = [];
        this.usedCodes.clear();
        for (let i = 0; i < this.numPoints; i++) {
          const speed = this.minSpeed + Math.random() * (this.maxSpeed - this.minSpeed);
          const angle = Math.random() * 2 * Math.PI;
          const vx = Math.cos(angle) * speed * (Math.random() > 0.5 ? 1 : -1);
          const vy = Math.sin(angle) * speed * (Math.random() > 0.5 ? 1 : -1);
          const radiusVariation = 1 + (Math.random() * 2 - 1) * this.pointRadiusVariation;
          const radius = this.pointRadius * radiusVariation;

          this.points.push({
            id: i,
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            vx, vy, radius,
            transformed: false,
            expanded: false,
            removed: false,
          });
        }
      }

      setupSVG() {
        while (this.svg.firstChild) {
          this.svg.removeChild(this.svg.firstChild);
        }

        const linesLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
        linesLayer.id = "lines-layer";

        const effectsLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
        effectsLayer.id = "effects-layer";

        const pointsLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
        pointsLayer.id = "points-layer";

        this.svg.append(linesLayer, effectsLayer, pointsLayer);

        this.points.forEach((p) => {
          if (p.removed) return;
          if (!p.code) {
            const val = this.getRandomPointValue();
            p.code = val.code;
            p.codeType = val.codeType;
            p.description = val.description;
          }

          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.id = `point-${p.id}`;
          g.setAttribute("transform", `translate(${p.x},${p.y})`);

          const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.id = `rect-${p.id}`;
          rect.setAttribute("x", -p.radius);
          rect.setAttribute("y", -p.radius);
          rect.setAttribute("width", p.radius * 2);
          rect.setAttribute("height", p.radius * 2);
          rect.setAttribute("rx", p.radius);
          rect.setAttribute("ry", p.radius);
          rect.setAttribute("fill", COLORS.WHITE);
          rect.setAttribute("stroke", COLORS.CONNECTION);
          rect.setAttribute("stroke-width", "1.5");

          const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.id = `text-${p.id}`;
          text.setAttribute("x", 0);
          text.setAttribute("y", 0);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.setAttribute("font-size", "10");
          text.setAttribute("opacity", "0");
          text.textContent = p.code;

          g.append(rect, text);
          pointsLayer.appendChild(g);
        });
      }

      animate() {
        if (!this.animationReady) return;

        this.points.forEach((p) => {
          if (p.removed) return;
          // simple centering force
          const cx = this.width / 2, cy = this.height / 2;
          p.vx += (cx - p.x) * 1e-6;
          p.vy += (cy - p.y) * 1e-6;
          p.x += p.vx;
          p.y += p.vy;
          if (p.x < 0 || p.x > this.width) p.vx *= -1;
          if (p.y < 0 || p.y > this.height) p.vy *= -1;
          p.x = Math.max(0, Math.min(this.width, p.x));
          p.y = Math.max(0, Math.min(this.height, p.y));
          const g = document.getElementById(`point-${p.id}`);
          if (g) g.setAttribute("transform", `translate(${p.x},${p.y})`);
        });

        if (this.showConnections) this.updateConnections();
        requestAnimationFrame(() => this.animate());
      }

      calculateConnections() {
        const valid = this.points.filter(p => !p.removed);
        const conns = [];
        const now = Date.now();
        valid.forEach((p1, i) => {
          const dists = [];
          valid.forEach((p2, j) => {
            if (i === j) return;
            const dx = p1.x - p2.x, dy = p1.y - p2.y, dist = Math.hypot(dx, dy);
            if (dist <= this.maxConnectionCreateDistance) dists.push({ idx: j, dist });
          });
          dists.sort((a, b) => a.dist - b.dist);
          dists.slice(0, 2).forEach(n => {
            if (i < n.idx) {
              const p2 = valid[n.idx];
              conns.push({
                id: `${p1.id}-${p2.id}`,
                x1: p1.x, y1: p1.y,
                x2: p2.x, y2: p2.y,
                sourceId: p1.id,
                targetId: p2.id,
                createdAt: now
              });
            }
          });
        });
        return conns;
      }

      createConnectionLines() {
        if (!this.showConnections) return;
        const layer = document.getElementById("lines-layer");
        while (layer.firstChild) layer.removeChild(layer.firstChild);
        this.connections.forEach(conn => {
          const line = document.createElementNS("http://www.w3.org/2000/svg","line");
          line.id = `conn-${conn.id}`;
          line.setAttribute("x1", conn.x1);
          line.setAttribute("y1", conn.y1);
          line.setAttribute("x2", conn.x2);
          line.setAttribute("y2", conn.y2);
          line.setAttribute("stroke", COLORS.CONNECTION);
          line.setAttribute("stroke-width", "1.5");
          line.setAttribute("opacity", "1");  // always fully visible
          layer.appendChild(line);
        });
      }

      updateConnections() {
        const updated = this.calculateConnections();
        const layer = document.getElementById("lines-layer");
        const keep = new Set();

        updated.forEach(conn => {
          keep.add(conn.id);
          let line = document.getElementById(`conn-${conn.id}`);
          if (line) {
            line.setAttribute("x1", conn.x1);
            line.setAttribute("y1", conn.y1);
            line.setAttribute("x2", conn.x2);
            line.setAttribute("y2", conn.y2);
          } else {
            line = document.createElementNS("http://www.w3.org/2000/svg","line");
            line.id = `conn-${conn.id}`;
            line.setAttribute("x1", conn.x1);
            line.setAttribute("y1", conn.y1);
            line.setAttribute("x2", conn.x2);
            line.setAttribute("y2", conn.y2);
            line.setAttribute("stroke", COLORS.CONNECTION);
            line.setAttribute("stroke-width", "1.5");
            line.setAttribute("opacity", "1");
            layer.appendChild(line);
          }
        });

        // remove stale
        document.querySelectorAll('line[id^="conn-"]').forEach(l => {
          const id = l.id.replace('conn-','');
          if (!keep.has(id)) layer.removeChild(l);
        });

        this.connections = updated;
      }

      transformConnectedPoints() {
        const active = this.connections;
        const ids = new Set(active.flatMap(c => [c.sourceId, c.targetId]));
        const toExpand = this.points.filter(p => ids.has(p.id) && !p.expanded && !p.removed).slice(0, 15);
        toExpand.forEach((p, i) => {
          setTimeout(() => this.expandPointAndShowText(p.id), i * 50);
        });
      }

      expandPointAndShowText(pointId) {
        const rect = document.getElementById(`rect-${pointId}`);
        const text = document.getElementById(`text-${pointId}`);
        const p = this.points.find(x => x.id === pointId);
        if (!rect || !text || !p) return;
        p.expanded = true;
        const orig = p.code || "";
        text.setAttribute("opacity", "1");
        text.textContent = orig;
        // pill shape
        const h = 24;
        const w = Math.max(orig.length * 8, 140);
        rect.setAttribute("x", -w / 2);
        rect.setAttribute("y", -h / 2);
        rect.setAttribute("width", w);
        rect.setAttribute("height", h);
        rect.setAttribute("rx", h / 2);
        rect.setAttribute("ry", h / 2);
      }

      handleResize() {
        this.animationReady = false;
        if (this.connectionRewireInterval) clearInterval(this.connectionRewireInterval);
        document.getElementById("lines-layer").innerHTML = "";
        this.connections = [];
        this.updateSize();
        this.initializePoints();
        this.setupSVG();
        this.showConnections = true;
        this.connections = this.calculateConnections();
        this.createConnectionLines();
        this.transformConnectedPoints();
        this.animationReady = true;
      }
    }

    // Initialize the animation when the page loads
    window.addEventListener('load', () => {
      const container = document.getElementById('container');
      new KnowledgeGraphAnimation(container);
    });
  </script>
</body>

</html>
