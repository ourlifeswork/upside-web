<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Upside Attribution Graph</title>
  <!-- Load anime.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: transparent;
      font-family: 'Inter', sans-serif;
    }

    .container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background-color: transparent;
    }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <div class="container" id="container">
    <svg id="svg"></svg>
  </div>

  <script>
    // Color constants for Upside attribution data
    const COLORS = {
      PEOPLE: "#D94B50",
      PEOPLE_DARK: "#B73E42",
      SIGNALS: "#E6774A",
      SIGNALS_DARK: "#D4653F",
      EVENTS: "#835CE0",
      EVENTS_DARK: "#7049C7",
      ENGAGEMENT: "#347BD1",
      ENGAGEMENT_DARK: "#2D6BB8",
      ROLES: "#66AF48",
      ROLES_DARK: "#5A9B3F",
      FALLBACK: "#F1CA66",
      FALLBACK_DARK: "#E8B955",
      CONNECTION: "#c7cacd",
      WHITE: "white",
      BLACK: "black",
    };

    // Upside attribution data
    const codes = {
      people: [
        { code: "Edith Harris (CEO)", description: "Chief Executive Officer" },
        { code: "VP Legal, Vonda H.", description: "Vice President of Legal" },
        { code: "Marcus Chen (CTO)", description: "Chief Technology Officer" },
        { code: "Sarah Kim (CFO)", description: "Chief Financial Officer" },
        { code: "Director IT, James R.", description: "IT Director" },
        { code: "Lisa Wong (CPO)", description: "Chief Product Officer" },
        { code: "David Miller (VP Sales)", description: "Vice President of Sales" },
        { code: "Head of Security, Alex T.", description: "Security Lead" },
        { code: "Michael Johnson (COO)", description: "Chief Operating Officer" },
        { code: "Emma Rodriguez (CMO)", description: "Chief Marketing Officer" },
      ],
      signals: [
        { code: "Opened Sales Deck", description: "Viewed presentation materials" },
        { code: "Clicked Ad", description: "Engaged with advertising content" },
        { code: "Shared Org Chart", description: "Distributed organizational information" },
        { code: "Downloaded Whitepaper", description: "Accessed thought leadership content" },
        { code: "Visited Pricing Page", description: "Reviewed pricing information" },
        { code: "Watched Demo Video", description: "Consumed product demonstration" },
        { code: "Joined Webinar", description: "Attended online presentation" },
        { code: "Requested Trial", description: "Initiated product evaluation" },
        { code: "Viewed Case Study", description: "Examined success stories" },
        { code: "Subscribed to Newsletter", description: "Opted in for regular updates" },
      ],
      events: [
        { code: "Warriors Game", description: "Corporate entertainment event" },
        { code: "Internal Demo Review", description: "Product demonstration session" },
        { code: "Executive Offsite", description: "Leadership retreat meeting" },
        { code: "Industry Conference", description: "Professional networking event" },
        { code: "Board Meeting", description: "Executive governance session" },
        { code: "Customer Advisory", description: "Strategic feedback session" },
        { code: "Partner Summit", description: "Ecosystem collaboration event" },
        { code: "Product Launch", description: "New feature announcement" },
        { code: "Annual Sales Kickoff", description: "Yearly sales strategy meeting" },
        { code: "Quarterly Business Review", description: "Performance assessment meeting" },
      ],
      engagement_types: [
        { code: "AE Email Intro", description: "Account Executive introduction" },
        { code: "Legal Redlines Sent", description: "Contract markup delivered" },
        { code: "Technical Deep Dive", description: "Product architecture review" },
        { code: "Security Review", description: "Compliance assessment meeting" },
        { code: "Pricing Discussion", description: "Commercial terms negotiation" },
        { code: "Reference Call", description: "Customer testimonial session" },
        { code: "POC Kickoff", description: "Proof of concept initiation" },
        { code: "Executive Briefing", description: "C-level strategic discussion" },
        { code: "Product Roadmap Review", description: "Future development planning" },
        { code: "Implementation Planning", description: "Deployment strategy session" },
      ],
      roles_tags: [
        { code: "Champion Identified", description: "Internal advocate confirmed" },
        { code: "Former Customer", description: "Previous client relationship" },
        { code: "Decision Maker", description: "Final approval authority" },
        { code: "Technical Evaluator", description: "Product assessment lead" },
        { code: "Budget Holder", description: "Financial approval authority" },
        { code: "Influencer", description: "Opinion leader in organization" },
        { code: "End User", description: "Product usage stakeholder" },
        { code: "Procurement Lead", description: "Vendor management contact" },
        { code: "Executive Sponsor", description: "Senior leadership support" },
        { code: "Project Manager", description: "Implementation coordinator" },
      ],
    };

    class KnowledgeGraphAnimation {
      constructor(container) {
        this.container = container;
        this.svg = document.getElementById("svg");
        this.points = [];
        this.connections = [];
        this.showConnections = false;
        this.animationReady = false;
        this.combinationDistance = 25;
        this.startTime = Date.now();
        this.width = 0;
        this.height = 0;
        this.usedCodes = new Set();
        this.connectionRewireInterval = null;

        // Constants
        this.numPoints = 48;
        this.maxSpeed = 0.7;
        this.minSpeed = 0.2;
        this.pointRadius = 4;
        this.pointRadiusVariation = 0.3;
        this.maxConnectionCreateDistance = 180;
        this.maxConnectionBreakDistance = 210;
        this.initialCombinationDistance = 25;
        this.maxCombinationDistance = 80;
        this.combinationDistanceIncreaseRate = 0.01;
        this.connectionLifespan = 30000;
        this.connectionRewireRate = 1500;
        this.connectionRewirePercentage = 0.15;

        this.init();
      }

      init() {
        // Set initial size
        this.updateSize();

        // Initialize points
        this.initializePoints();

        // Create SVG elements
        this.setupSVG();

        // Start animation
        this.animationReady = true;
        this.animate();

        // Always show connections immediately
        this.showConnections = true;
        this.connections = this.calculateConnections();
        this.createConnectionLines();
        this.transformConnectedPoints();

        // Resize handling
        window.addEventListener("resize", () => this.handleResize());
      }

      updateSize() {
        this.width = this.container.clientWidth;
        this.height = this.container.clientHeight;
        this.svg.setAttribute("width", this.width);
        this.svg.setAttribute("height", this.height);
      }

      getRandomPointValue() {
        try {
          const contentTypes = ["people", "signals", "events", "engagement_types", "roles_tags"];
          const typeRoll = Math.random();
          let selectedType;
          if (typeRoll < 0.2) selectedType = "people";
          else if (typeRoll < 0.4) selectedType = "signals";
          else if (typeRoll < 0.6) selectedType = "events";
          else if (typeRoll < 0.8) selectedType = "engagement_types";
          else selectedType = "roles_tags";

          const dataList = codes[selectedType];
          if (!dataList || dataList.length === 0) {
            return { code: "Unknown", codeType: selectedType, isCode: false };
          }

          let attempts = 0, selectedItem, selectedCode;
          while (attempts < 20) {
            const idx = Math.floor(Math.random() * dataList.length);
            selectedItem = dataList[idx];
            selectedCode = selectedItem.code;
            if (!this.usedCodes.has(selectedCode)) {
              this.usedCodes.add(selectedCode);
              break;
            }
            attempts++;
          }

          if (attempts >= 20 || !selectedItem) {
            const uniqueCode = this.generateUniqueCode(selectedType);
            return { code: uniqueCode, description: `Generated ${selectedType}`, codeType: selectedType, isCode: false };
          }

          return { code: selectedItem.code, description: selectedItem.description, codeType: selectedType, isCode: false };
        } catch (err) {
          console.error("Error selecting point value:", err);
          return { code: "ERROR", codeType: "people", isCode: false };
        }
      }

      generateUniqueCode(type) {
        const uniqueId = Math.floor(Math.random() * 10000);
        switch (type) {
          case "people":
            const fn = ["John","Jane","Alex","Sam"][Math.floor(Math.random()*4)];
            const ln = ["Smith","Jones","Lee","Brown"][Math.floor(Math.random()*4)];
            return `Analyst ${fn} ${ln.charAt(0)}.`;
          case "signals":
            return `Viewed Resource ${uniqueId}`;
          case "events":
            return `Strategy Session ${uniqueId}`;
          case "engagement_types":
            return `Product Call ${uniqueId}`;
          case "roles_tags":
            return `Key Stakeholder ${uniqueId}`;
          default:
            return `Unknown ${uniqueId}`;
        }
      }

      initializePoints() {
        this.points = [];
        this.usedCodes.clear();
        for (let i = 0; i < this.numPoints; i++) {
          const speed = this.minSpeed + Math.random() * (this.maxSpeed - this.minSpeed);
          const angle = Math.random() * Math.PI * 2;
          const vx = Math.cos(angle) * speed * (Math.random()>0.5?1:-1);
          const vy = Math.sin(angle) * speed * (Math.random()>0.5?1:-1);
          const radius = this.pointRadius * (1 + (Math.random()*2-1)*this.pointRadiusVariation);
          this.points.push({ id:i, x:Math.random()*this.width, y:Math.random()*this.height, vx, vy, radius, expanded:false, removed:false });
        }
      }

      setupSVG() {
        while (this.svg.firstChild) this.svg.removeChild(this.svg.firstChild);
        const linesLayer   = document.createElementNS("http://www.w3.org/2000/svg","g"); linesLayer.id="lines-layer";
        const effectsLayer = document.createElementNS("http://www.w3.org/2000/svg","g"); effectsLayer.id="effects-layer";
        const pointsLayer  = document.createElementNS("http://www.w3.org/2000/svg","g"); pointsLayer.id="points-layer";
        this.svg.append(linesLayer, effectsLayer, pointsLayer);

        this.points.forEach(pt => {
          if (pt.removed) return;
          if (!pt.code) {
            const val = this.getRandomPointValue();
            pt.code = val.code;
            pt.codeType = val.codeType;
          }
          const group = document.createElementNS("http://www.w3.org/2000/svg","g");
          group.id = `point-${pt.id}`;
          group.setAttribute("transform", `translate(${pt.x},${pt.y})`);
          const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
          rect.id = `rect-${pt.id}`;
          rect.setAttribute("x", -pt.radius);
          rect.setAttribute("y", -pt.radius);
          rect.setAttribute("width", pt.radius*2);
          rect.setAttribute("height", pt.radius*2);
          rect.setAttribute("rx", pt.radius);
          rect.setAttribute("ry", pt.radius);
          rect.setAttribute("fill", COLORS.WHITE);
          rect.setAttribute("stroke", COLORS.CONNECTION);
          rect.setAttribute("stroke-width", "1.5");
          const text = document.createElementNS("http://www.w3.org/2000/svg","text");
          text.id = `text-${pt.id}`;
          text.setAttribute("x", 0);
          text.setAttribute("y", 0);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.setAttribute("font-size", "10");
          text.setAttribute("opacity", "0");
          text.textContent = pt.code;
          group.append(rect, text);
          pointsLayer.appendChild(group);
        });
      }

      animate() {
        if (!this.animationReady) return;
        this.points.forEach(pt => {
          if (pt.removed) return;
          const cx = this.width/2, cy = this.height/2;
          pt.vx += (cx-pt.x)*1e-6;
          pt.vy += (cy-pt.y)*1e-6;
          pt.x += pt.vx;
          pt.y += pt.vy;
          if (pt.x<0||pt.x>this.width) pt.vx*=-1;
          if (pt.y<0||pt.y>this.height) pt.vy*=-1;
          pt.x = Math.max(0,Math.min(this.width,pt.x));
          pt.y = Math.max(0,Math.min(this.height,pt.y));
          const g = document.getElementById(`point-${pt.id}`);
          if (g) g.setAttribute("transform", `translate(${pt.x},${pt.y})`);
        });
        if (this.showConnections) this.updateConnections();
        requestAnimationFrame(() => this.animate());
      }

      calculateConnections() {
        const valid = this.points.filter(p=>!p.removed);
        const conns = [];
        const now = Date.now();
        for (let i=0;i<valid.length;i++){
          const p1=valid[i], dists=[];
          for (let j=0;j<valid.length;j++){
            if(i===j) continue;
            const p2=valid[j];
            const dx = p1.x-p2.x, dy=p1.y-p2.y, dist=Math.hypot(dx,dy);
            if(dist<=this.maxConnectionCreateDistance) dists.push({idx:j,dist});
          }
          dists.sort((a,b)=>a.dist-b.dist);
          for (let k=0;k<Math.min(2,dists.length);k++){
            const other = dists[k].idx;
            if(i<other){
              conns.push({ id:`${p1.id}-${valid[other].id}`, x1:p1.x,y1:p1.y,x2:valid[other].x,y2:valid[other].y, sourceId:p1.id, targetId:valid[other].id, createdAt:now });
            }
          }
        }
        return conns;
      }

      createConnectionLines() {
        if (!this.showConnections) return;
        const layer = document.getElementById("lines-layer");
        while (layer.firstChild) layer.removeChild(layer.firstChild);
        this.connections.forEach(conn => {
          const line = document.createElementNS("http://www.w3.org/2000/svg","line");
          line.id = `conn-${conn.id}`;
          line.setAttribute("x1", conn.x1);
          line.setAttribute("y1", conn.y1);
          line.setAttribute("x2", conn.x2);
          line.setAttribute("y2", conn.y2);
          line.setAttribute("stroke", COLORS.CONNECTION);
          line.setAttribute("stroke-width", "1.5");
          line.setAttribute("opacity", "1");
          layer.appendChild(line);
        });
      }

      updateConnections() {
        const updated = this.calculateConnections();
        const layer = document.getElementById("lines-layer");
        updated.forEach(conn => {
          let line = document.getElementById(`conn-${conn.id}`);
          if (line) {
            line.setAttribute("x1", conn.x1);
            line.setAttribute("y1", conn.y1);
            line.setAttribute("x2", conn.x2);
            line.setAttribute("y2", conn.y2);
          } else {
            line = document.createElementNS("http://www.w3.org/2000/svg","line");
            line.id = `conn-${conn.id}`;
            line.setAttribute("x1", conn.x1);
            line.setAttribute("y1", conn.y1);
            line.setAttribute("x2", conn.x2);
            line.setAttribute("y2", conn.y2);
            line.setAttribute("stroke", COLORS.CONNECTION);
            line.setAttribute("stroke-width", "1.5");
            line.setAttribute("opacity", "1");
            layer.appendChild(line);
          }
        });
        // remove stale
        const keep = new Set(updated.map(c=>c.id));
        document.querySelectorAll('line[id^="conn-"]').forEach(l => {
          const id = l.id.replace('conn-','');
          if (!keep.has(id)) layer.removeChild(l);
        });
        this.connections = updated;
      }

      transformConnectedPoints() {
        const active = this.connections;
        const ids = new Set(active.flatMap(c=>[c.sourceId,c.targetId]));
        const toExpand = this.points.filter(p=>ids.has(p.id)&&!p.expanded&&!p.removed).slice(0,15);
        toExpand.forEach((pt,i)=>{
          setTimeout(()=>this.expandPointAndShowText(pt.id), i*50);
        });
      }

      expandPointAndShowText(id) {
        const rect = document.getElementById(`rect-${id}`);
        const text = document.getElementById(`text-${id}`);
        const pt = this.points.find(p=>p.id===id);
        if (!rect||!text||!pt) return;
        pt.expanded = true;
        const orig = pt.code||"";
        const height = 24;
        const width = Math.max(pt.codeType==="people"||pt.codeType==="roles_tags"?60:140, Math.min(300, orig.length * 8));
        rect.setAttribute("x", -width/2);
        rect.setAttribute("y", -height/2);
        rect.setAttribute("width", width);
        rect.setAttribute("height", height);
        rect.setAttribute("rx", height/2);
        rect.setAttribute("ry", height/2);
        text.setAttribute("opacity","1");
        text.textContent = orig;
      }

      handleResize() {
        this.animationReady = false;
        if (this.connectionRewireInterval) clearInterval(this.connectionRewireInterval);
        document.getElementById("lines-layer").innerHTML = "";
        this.connections = [];
        this.updateSize();
        this.initializePoints();
        this.setupSVG();
        this.showConnections = true;
        this.connections = this.calculateConnections();
        this.createConnectionLines();
        this.transformConnectedPoints();
        this.animationReady = true;
      }
    }

    // Initialize the animation when the page loads
    window.addEventListener('load', () => {
      const container = document.getElementById('container');
      new KnowledgeGraphAnimation(container);
    });
  </script>
</body>

</html>
